//#define LINUX
#include <string>
//////////////////////////////////////////////////////////////////////////
//信号的生命周期？
//信号产生 - 》信号在进程中注册 - 》信号在进程中的注销 - 》执行信号处理函数
//////////////////////////////////////////////////////////////////////////
//信号的产生方式？
//（1）当用户按某些终端键时产生信号
//（2）硬件异常产生信号【内存非法访问】
//（3）软件异常产生信号【某一个条件达到时】
//（4）调用kill函数产生信号【接受和发送的所有者必须相同，或者发送的进程所有者必须为超级用户】
//（5）运行kill命令产生信号
//////////////////////////////////////////////////////////////////////////
//信号处理方式？
//（1）执行默认处理方式（2）忽略处理（3）执行用户自定义的函数
//////////////////////////////////////////////////////////////////////////
//如何消除隐式转换？
//使用explicit关键字进行修饰
//////////////////////////////////////////////////////////////////////////
//TODO:3.重载，重写和隐藏的区别？
//重载：即函数重载 
//重写【覆盖】：即用于虚函数
//隐藏：只要派生类的函数名与基类相同就会隐藏 
//////////////////////////////////////////////////////////////////////////
//TODO:volatile表示什么？有什么作用？
//易变的，不会被编译器进行优化，让程序取数据直接去内存中的。
//////////////////////////////////////////////////////////////////////////
//#static_cast<>, dynamic_cast<>, const_cast<>, reinterpret_cast<>的各自作用和使用环境？
//static_cast：能完成大部分转换功能，但是并不确保安全
//const_cast：无法从根本上转变类型，如果是const，它就依旧是const, 只是如果原对象不是const, 可以通过此转换来处理，针对指针和引用而言。
//dynamic_cast：针对基类和派生类指针和引用转换，基类和派生类之间必须要继承关系，是安全的
//reinterpret_cast：允许将任何指针类型转为其他指针类型，是安全的

//////////////////////////////////////////////////////////////////////////
//malloc和new的区别？
//malloc：
//内存分配错误时，返回NULL；本身是一个库函数；分配内存的地方为堆；只申请内存空间；需要指定申请多大的内存；
//new：
//内存分配错误时，抛出bad_alloc异常，可以定义set_new_handler函数来在产生异常时进行处理；本身是一个运算符；
//分配内存的地方为自由存储区【为一个抽象概念】；对于对象而言，会先申请内存空间然后调用构造函数；无需指定大小。

//////////////////////////////////////////////////////////////////////////
//free和delete的区别？
//delete：
//本身是一个运算符
//free：
//本身是一个库函数

//////////////////////////////////////////////////////////////////////////
//TODO:free一个数组时如何知道要释放多大的内存呢？
//一般在数组前面几个字节中存在某一个结构体来保存当前申请的数组大小。

//////////////////////////////////////////////////////////////////////////
//TODO:__stdcall和__cdecl的区别？
//__stdcall：
//从右往左压栈，堆栈参数数据由函数本身清除，一般是通过汇编指令ret x, x表示弹出x个字节，参数必须是确定，
//必须为函数本身知晓，所以此关键字不能用于有可变参数应用的函数声明。
//__cdecl：
//从右往左压栈，由调用者来对堆栈数据进行清除，步骤：调用方调用函数 - 》函数执行 - 》函数结果返回 - 》调用方清除堆栈参数，主要针对可变参数

//////////////////////////////////////////////////////////////////////////
//linux内部提供了那些调试宏？
//__FILE__：表示在哪个文件
//__LINE__：表示在当前多少行
//__FUNCTION__：表示在执行在哪个函数

//////////////////////////////////////////////////////////////////////////
//#1.手撕线程安全的单例模式
#ifdef LINUX
class Singlton
{
private://私有，考点
    static pthread_mutex_t mtx;//静态，考点
    static Singlton* instance;
    Singlton() {}
    ~Singlton() {}
public:
    static Singlton* getInstance()
    {
        if (instance == NULL)
        {
            pthread_mutex_lock(mtx);
            if (instance == NULL)
                instance = new Singlton();
            pthread_mutex_unlock(mtx);
        }
        return instance;
    }
};
pthread_mutex_t Singlton::mtx = PTHREAD_MUTEX_INITIALIZER;//# define PTHREAD_MUTEX_INITIALIZER { { 0, 0, 0, 0, 0, 0, { 0, 0 } } }
Singlton* Singlton::instance = NULL;
#endif

//////////////////////////////////////////////////////////////////////////
//引用和指针的区别？
//指针：是一个变量类型；指针可以不进行初始化；指针初始化后可以改变，在写代码时需要大量的检测
//引用：是一个别名；引用必须要初始化；引用初始化后不可改变，无需检测

//////////////////////////////////////////////////////////////////////////
//TODO:出现异常时，try和catch做了什么？
//Catch(Ep a)发生异常 - 》建立一个异常对象 - 》拷贝一个异常对象 - 》catch处理
//Catch(Ep &a)发生异常 - 》建立一个异常对象 - 》引用异常对象 - 》catch处理
//异常对象通常建立在全局或者堆中【需要在函数外进行捕捉】
//Catch捕捉异常的转换：异常处理时，如果用基类的处理派生类的对象会导致派生类完全当做基类来使用，即便有虚函数也没用，所以派生类必须放在基类前处理。

//////////////////////////////////////////////////////////////////////////
//C++如何处理多个异常的？
//多次catch处理

//////////////////////////////////////////////////////////////////////////
//TODO:常对象的成员变量一定不可以修改吗？为什么？
//可以修改，用mutable来修饰，可以突破const的限制。

//////////////////////////////////////////////////////////////////////////
//TODO:虚函数的调用过程？
//找到对象内存中vfptr所指向虚函数表的地址 - 》找到虚函数表相应的虚函数地址

//////////////////////////////////////////////////////////////////////////
//汇编层面：
//Mov ecx, dword ptr[ebp - 0ch]将this指针放进ecx
//Mov edx, dword ptr[ecx]将虚表的地址放进edx
//Call dword ptr[edx + 4]：调用虚表中函数
//虚函数放置顺序与声明顺序一样，成员变量也是
//虚表中放的不是函数的入口地址，而是一个jmp跳转指令的地址

//////////////////////////////////////////////////////////////////////////
//#C/C++编译器的选择
//gcc/g++ 和 clang/clang++ 都是 Linux 下常用的 C/C++ 编译器, 优先级是clang++>g++>msvc。还有个ICC

//////////////////////////////////////////////////////////////////////////
//TODO:单继承，多继承，菱形继承，虚继承时，对象内存中的差异区别？如果存在虚函数呢？
//单继承：
class EmptyClass
{
    //virtual int f() 
    //{ 
    //    int a = 1;
    //    a += a;
    //    return a;
    //}
    /*virtual*/ int f2()
    {
        int a = 1;
        a += a;
        return a;
    }
    //int c;
    //char a;
    static int b;
};
int EmptyClass::b = 0;

class Base
{
public:
    int a;
    virtual void f(){}
};
class Base2
{
public:
    int a2;
    virtual void f3() {}
};
class Der1: public virtual Base
{
public:
    int b;
    void virtual f() {}
    //void virtual f2() {}
};
class Der2: public virtual Base, public Base2
{
public:
    int c;
    void f() {}
    void virtual f2() {}
};
class Der3 : public Base
{
public:
    //int b;
    //void f() {}
};
class Der4 : public virtual EmptyClass
{
public:
    //int b;
    //void f() {}
};
class Der5 : public virtual Der2
{
public:
    int b;
    //void f() {}
};
//https://blog.csdn.net/xiejingfa/article/details/48028491
int main()
{
    Base d0;
    Der1 d1;
    Der2 d2;
    //Der3 d3;
    //d2.a = 1;
    //d2.b = 2;
    //d2.c = 3;
    int base = sizeof(Base);
    int der1 = sizeof(Der1);
    int der2 = sizeof(Der2);
    //int der2 = sizeof(Der2);
    //int p1 = 0;
    //int p2 = 0;
    //int *p1 = NULL;
    //int *p2 = NULL;
    //int *pp1 = &p1;
    //int *pp2 = &p2;
    //int s4 = sizeof(EmptyClass);
    //int s5 = sizeof(Der3);
    //int s6 = sizeof(d1);
    //int s7 = sizeof(d2);
    //int s8 = sizeof(d3);
    //int s9 = sizeof(Der4);
    //int s10 = sizeof(Der5);
    return 0;
}

class A
{
public:
    int a;
    virtual void f() {}
    //virtual void f2() {}
    //void f4() { printf("a"); }
};
class B: public /*virtual*/ A
{
public:
    int b;
    /*virtual*/ void f() {}
    //void f4() { printf("c"); }
};
class C: public virtual A
{
public:
    int c;
    /*virtual*/ void f() {}
    //virtual void f3() {}
    //void f4() { printf("c"); }
};
class D : public C
{
public:
    int d;
    /*virtual*/ void f() {}
};

int max1(int x, int y)
{
    return x > y ? x : y;
}
int main39()
{
    //D d;
    //A a;
    //B b;
    //C c;
    //int sa = sizeof(A);
    //int sb = sizeof(B);
    //int sc = sizeof(C);
    //int sd = sizeof(D);
    //int d1 = sizeof(d);
    //A *aa = new B;
    {
        char *str[] = { "wel","topyu","fortem","nanjing" };
        char **p = str + 1;
        str[0] = (*p++) + 2;
        str[1] = *(p + 1);
        str[2] = p[1] + 3;
        str[3] = p[0] + (str[2] - str[1]);
    }

    int(*p[2])(int,int);
    int max1(int,int);
    p[0] = max1;
    int ret = (p[0])(3,2);
    return 0;
}

char * getm()
{
    char p[] = "hello";
    return p;
}
char * getm2()
{
    char *p = "hello";
    return p;
}
int main22()
{
    int i = 0;
    int ii = 0;
    char * p = getm2();
    printf("%s,%s,%d,%d,%d,%d", getm(), p,getm2,&i,&ii,&p);
    return 0;
}
extern int ejj;
extern int sjj=8;
extern int sfun();
class AA
{
public:
    //AA(int a):aa(a) {
    //    printf("\n11111111,%d",this);
    //}
    AA() /*:aa(2)*/ {
        //printf("\n22222222,%d,%d", aa, this);
    }
    ~AA() {
        //printf("\n44444444,%d,%d", aa,this);
    }
    //AA(AA &a) {
    //    aa = a.aa;
    //    printf("\n33333333,%d", this);
    //}
    void fun() {};
    void *operator new(size_t size, char caint)
    {
        void *tmp = malloc(size);
        memset(tmp, caint, size);
        printf("\noperator,%c", *(char *)tmp);
        return tmp;
    }
public:
    //int aa;
};
AA play(AA a)
{
    printf("\n66666666,%d", &a);
    return a;
}
int main66()
{
    AA *aaa = new('s') AA;
    printf("\n66666666,%c", *(char* )aaa);
    ///*AA bb =*/ play(2);
    //printf("\n55555555,%d", &bb);

    //aa.fun();
    //aab.fun();
    //aab.a;
    //int ss = sfun() + sjj;
    //int i = 5.01;
    //float f = 5;
    //printf("%1f\n", 5.01);
    //printf("%f\n", f);
    //printf("%d\n", 5.01);
    //printf("%d\n", i);
    return 0;
}
//成为虚函数的条件：
//1.要能取地址
//2.依赖对象调用

//构造函数 不可以 系统调用 不依赖对象调用
//析构函数 可以
//内联函数 不可以 不能取地址 函数在调用点直接展开
//static函数 不可以 无this指针 不依赖对象调用

//虚函数表：
//第一行：RTTL（run time type information）运行时类型信息
//第二行：虚函数指针的偏移
//第三行：虚函数的入口地址
//虚表的写入时机 构造函数的执行之前

//////////////////////////////////////////////////////////////////////////
//实现一个vector？是1.5还是2倍，各有什么优缺点？
//1.5倍优势：可以重用之前分配并且释放的内存
//2倍劣势：每次申请的内存都不可以重用
//1，2，4，8，16，32，...
//可以看到到第三次resize(4)的时候，前面释放的总和只有1 + 2 = 3，到第四次resize(8)的时候前面释放的总和只有1 + 2 + 4 = 7，
//每次需要申请的空间都无法用到前面释放的内存。

//////////////////////////////////////////////////////////////////////////
//map底层用了什么？
//红黑树

////////////////////////////////////////////////////////////////////////////
//如果用map删除了一个元素，迭代器还能用吗？为什么？怎样做可以接着用？
//能用，a.erase(it++)；因为是直接申请的内存，所以可以直接通过获取后续节点来处理

//////////////////////////////////////////////////////////////////////////
//红黑树的特征是什么？
//（1）根节点为黑色
//（2）一个节点为红色，子节点必定为黑色
//（3）从任意一点触发到达每一个叶子节点的黑色节点个数相同
//（4）每一个节点不是红色就是黑色
//（5）每一个叶子节点都是黑色

//////////////////////////////////////////////////////////////////////////
//红黑树如何插入和删除的？
//插入：
//（1）如果父节点为黑色，直接插入不处理
//（2）如果父节点为红色，叔叔节点为红色，则父节点和叔叔节点变为黑色，祖先节点变为红色，将节点操作转换为祖先节点
//（3）如果当前节点为父亲节点的右节点，则以父亲结点为中心左旋操作
//（4）如果当前节点为父亲节点的左节点，则父亲节点变为黑色，祖先节点变为红色，以祖先节点为中心右旋操作
//删除：
//（1）先按照排序二叉树的方法，删除当前节点，如果需要转移即转移到下一个节点
//（2）当前节点，必定为这样的情况：没有左子树。
//（3）删除为红色节点，不需要处理，直接按照删除二叉树节点一样
//（4）如果兄弟节点为黑色，兄弟节点的两个子节点为黑色，则将兄弟节点变为红色，将着色转移到父亲节点
//（5）如果兄弟节点为红色，将兄弟节点设为黑色，父亲结点设为红色节点，对父亲结点进行左旋操作
//（6）如果兄弟节点为黑色，左孩子为红色，右孩子为黑色，对兄弟节点进行右旋操作
//（7）如果兄弟节点为黑色，右孩子为红色，则将父亲节点的颜色赋值给兄弟节点，将父亲节点设置为黑色，将兄弟节点的右孩子设为黑色，对父亲节点进行左旋

//////////////////////////////////////////////////////////////////////////
//红黑树和B + , B - 的区别？
//红黑树的深度比较大，而B + 和B - 的深度则相对要小一些，而B + 较B - 则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。

//////////////////////////////////////////////////////////////////////////
//线程同步几种方式？
//互斥锁，信号量，临界区

//////////////////////////////////////////////////////////////////////////
//手写strcpy, memcpy, memmove函数？
//需要注意内存重叠问题

//////////////////////////////////////////////////////////////////////////
//Do{}while (0)的用法有哪些？
//（1）可以将语句当做一个独立的域
//（2）对于多语句可以正常的运行
//（3）可以有效的消除goto语句，达到跳转语句的效果

//////////////////////////////////////////////////////////////////////////
//手写快排？时间复杂度？空间复杂度？能进行优化吗？还有吗？能进行尾递归优化吗？
//最优时间复杂度：nlogn
//最差时间复杂度：n ^ 2
//平均时间复杂度：nlogn
//空间复杂度：logn->n
//优化：
//（1）随机
//（2）三数取中
//（3）当排序达到一定长度时用插入排序
//（4）分隔一次后，将相同数据不处理
//（5）使用并行或者多线程
//（6）进行尾递归优化【即将logn降解为更低的复杂度】

//////////////////////////////////////////////////////////////////////////
//线程池的作用是什么？
//处理线程多并发，用一个数组保存线程，然后一直放着，如果没用就用条件变量让它休眠，如果加入一个新的任务就唤醒其中一个去执行这个任务。

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//空类型不包含任何信息，按理来说它的sizeof应该是0。但是，要考虑的是当我们声明该类型的实例的时候，
//它必须在内存中占有一定的空间，否则它就是不存在的而无法使用这些实例。
//因此，具体在内存中占用的空间大小是多少由编译器确定，在vs中一个空类型的实例占用1字节的空间。

//1、栈区（stack）:由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
//2、堆区（heap）:一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
//3、全局区（静态区）（static）:全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束后由系统释放。
//4、文字常量区:常量字符串就是放在这里的。程序结束后由系统释放
//5、程序代码区:存放函数体的二进制代码。

//函数占的空间不在sizeof里，而在代码区里
//静态成员占的空间不在sizeof里，而在全局区里

//////////////////////////////////////////////////////////////////////////
//https://www.nowcoder.com/discuss/57978
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////